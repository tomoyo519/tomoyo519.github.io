# 🙊 명시적 가용 리스트

### Implicit free list와의 비교

- 묵시적 가용리스트는 모든 블럭을 다 순회하면서 가용영역을 찾아야 하는 단점이 있었다. 그래서 블럭 크기가 커지면 순회하는데 많은 시간을 사용하게 된다. 즉 블록 할당 시간이 전체 블록 크기에 따라 비례하게 된다.
- 그러면 가용블럭 끼리만 연결해 놓으면 순회할 시간이 줄어들지 않을까?

### Explicit free list

가용 리스트끼리 포인터로 연결되어있는 구조를 가진다.

![스크린샷 2023-09-12 19.59.52.png](../img/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2023-09-12_19.59.52.png)

- 힙블록 모양
  - 할당된 블록은 Implicit free list 와 동일하지만, 가용 블록은 아래와 같은 차이점이 있다.
    ![스크린샷 2023-09-11 20.00.01.png](../img/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2023-09-11_20.00.01.png)
    가용 블록의 payload 부분에 이전 가용 블록(prev, predecessor)의 포인터와 다음 가용 블록(next, successor)의 포인터를 저장해둔다는 차이가 있다.
    그래서 Implicit free list와 비교해서 2워드만큼 공간을 더 사용하게 된다.

### Explicit Free List 의 메모리 할당 방식

- 회색 부분 만큼 메모리가 할당 되었을때, 첫번째 블록과 세번째 블록의 포인터는
  두번째 블록에서 남은 가용 영역을 가리키게 된다.
  ![스크린샷 2023-09-12 20.09.45.png](../img/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2023-09-12_20.09.45.png)

### Explicit Free List 의 메모리 해제 방식

새로 해제된 블럭을 어디에 넣느냐에 따라 2가지로 분류된다.

- LIFO(last in first out) 정책
  - 할당 해제된 블럭을 가용 리스트 맨 앞에 넣는 방법
  - 장점 : 간단하고, 가용리스트를 검색할때 소요되는 시간이 O(1) 이다
  - 단점 : address ordered 방법에 비해 메모리 단편화 더 심하다고 알려져있다.
- Address-ordered 정책
  - 가용 리스트를 아래와 같은 메모리 순서로 관리하는 방식이다.
    `◦ *addr(prev) < addr(curr) < addr(next)*`
  - 장점 : LIFO 방법에 비해 단편화가 를 줄일 수 있다.
    왜냐하면 인접한 가용블록을 병합하여 더 큰 블록을 만드는 것이 용이해지기 떄문
  - 단점 : 가용 블록을 검색하는데 선형시간O(N)이 소요된다.

### Lifo 정책에서 메모리 해제시 case

1.  case1

    ![스크린샷 2023-09-12 20.23.00.png](../img/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2023-09-12_20.23.00.png)

    새로 할당된 블럭의 포인터를 bp 라고 하고,
    기존 가용리스트의 첫블록을 가리키는 포인터가 free_listp라고 한다면, 아래 절차를 거쳐야 반환된 블록의 삽입 절차가 완료 된다.

    ```c
    GET_PREV(bp) = NULL;
    GET_NEXT(bp) = free_listp;
    GET_PREV(free_listp) = bp;
    ```

2.  case2
    반환하는 블록의 뒤에있는 블록이 새로 가용되는경우,
    ![스크린샷 2023-09-12 20.30.41.png](../img/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2023-09-12_20.30.41.png)

        어쨋든 새로 반환된 블록이 맨 앞에 와야 되기 때문에 아래와 절차를 거쳐야 반환된 블록의 삽입 절차가 완료 된다.

        ```c
        GET_PREV(bp) = NULL;
        GET_NEXT(bp) = free_listp;
        GET_PREV(free_listp) = bp;

        //그리고 pred블록과 succ사이에 있는 블록이 가용 리스트의 맨 앞으로 이동해버렸으므로, pred 블록과
        //succ블록은 서로 앞뒤 블록으로 가리키면 된다.
        ```

- note: spliting 이 되서 free가 되면, 삭제를 먼저 한다(free list에서 삭제)
  삭제를 한 뒤에 사이즈를 늘려서 하나의 가용블록로 만들어주고, 가용리스트에 넣어주는것.

1. case3

   반환하는 블록의 앞에있는 블록이 새로 가용되는 경우, case2와 원리는 동일하다.

   ![스크린샷 2023-09-12 20.55.51.png](../img/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2023-09-12_20.55.51.png)

2. case4

   반환하는 블록의 앞뒤 블록이 가용 상태인 경우,
   역시 prev 블록의 succ블록이 앞뒤 블록으로 서로 가리키게 한다는 점에서 case2와 동일하다.

   ![스크린샷 2023-09-12 20.56.04.png](../img/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2023-09-12_20.56.04.png)
