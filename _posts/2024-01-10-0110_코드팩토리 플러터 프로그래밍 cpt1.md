# 코드팩토리의 플러터 프로그래밍

## 1단계 다트 언어 마스터하기

### chapter 01 다트 입문하기

**1.1 다트 소개**

구글이 개발한 다트 프로그래밍 언어.

장점

1. UI를 제작하는데 최적화 되어있음. 완전한 비동기 언어이며 이벤트 기반. isolate를 이용한 동시성 기능 제공
2. Null safety, Spread operator, collection if 등 효율적으로 UI를 코딩할 수 있는 기능 제공
3. 효율적인 개발 환경 제공. 핫리로드를 통해 코드의 변경사항을 즉시 화면에 반영
4. 멀티 플랫폼에서 로깅 및 디버깅 가능
5. AOT컴파일 가능하기 때문에 어떤 플랫폼에서든 빠른 속도
6. 자바스크립트로의 완전한 컴파일 지원
7. 백엔드 프로그래밍 지원

다트 언어는 자바스크립트 언어로 완전한 컴파일이 가능하며 네이티브 플랫폼과 마찬가지로 효율적인 개발을 위해 증분 컴파일을 지원함. (증분 컴파일 : 소스코드의 일부가 변경 되었을때, 전체를 다시 컴파일 하지 않고, 변경된 부분만 컴파일 하는 방식)

다트는 모바일이나 데스크톱 기기를 target 하는 네이티브 플랫폼과 웹을 target하는 웹 플랫폼으로 컴파일 할 수 있음. 다트 네이티브 플랫폼은 JIT(just in time) 방식과 AOT(ahead of Time) 컴파일 방식을 사용함. 소프트웨어를 효과적으로 개발하려면 코드의 변경된 사항을 화면에 반영해보고 수정하는 반복적인 과정이 빠른 사이클로 진행되어야함. JIT 컴파일 방식은 다트 가상 머신에서 제공하는 기능으로 코드의 변경사항을 처음부터 다시 컴파일 할 필요없이 즉시 화면에 반영할 수 있는 핫 리로드 기능, 실시간으로 매트릭스를 확인할 수 있는 기능, 디버깅 기능을 제공합니다. 개발하는 도중에는 빠르게 개발할 수 있는 효율이 중요하기 때문에 JIT컴파일 방식을 사용함. 하지만 소프트웨어를 배포할때는 목적코드로 변환되어 있어야 더욱 리소스를 효율적으로 사용할 수 있음. 그래서 배포시에는 AOT 컴파일 방식을 사용해서 컴파일함. AOT 컴파일 방식을 사용하면 ARM64나 x64 기계어로 다트 언어가 직접 컴파일이 되어서 매우 효율적으로 프로그램을 실행할 수 있음.

**1.3 기초문법 **

- 주석

  /// 슬래시 세개를 사용하면 문서 주석 작성 가능.

- var를 사용한 변수선언
  변수에 값이 들어가면 자동으로 타입을 추론하는 타입 추론 기능을 제공하므로, 명시적으로 타입을 선언하지 않아도 됨. 즉 타입을 한 번 유추하면 추론된 타입이 고정됨.

- dynamic 키워드로 변수를 선언하면 변수의 타입이 고정되지 않아 다른 타입의 값을 저장할 수 있음.

- final, const 키워드로 변수를 선언하면 처음 선언 후 변경할 수 없음.
  final은 런타임, const는 빌드타임 상수.
  코드를 실행하지 않은 상태에서 값이 확정되면 const, 실행할때 확정되면 final 을 사용해야 한다.

- 변수타입: 문자열, 정수, 실수, 불리언

- 컬렉션 : 여러값을 하나의 변수에 저장할 수 있는 타입. 서로의 타입으로 자유롭게 형변환이 가능함.

- List : 여러값을 순서대로 나열한 변수에 저장할때 사용.

```
List<String> blackPink = ['리사', '지수','제니','로제']
print(blackPink.length) //4
blackPink[3] = '정다희'
print(blackPink) = ['리사', '지수','제니','정다희']
```

​ List 에 기본 제공되는 함수
​ contains() : List 에 해당 값이 있는지 확인. 출력은 true / false 값으로 된다
​ add() : List 맨 뒤에 값을 추가할때 사용
​ where() : List 에 있는 값을 순회하면서 특정 조건에 맞는 값만 필터링. 매개변수에 함수를 입력해야하며, 입력된 함수는 기존 값을 하나씩 매개변수로 입력받음. true 면 유지, false 면 값을 버림. 순회가 끝나고 유지된 값을 기반으로 이터러블 반환

```
List<String> blackPink = ['리사', '지수','제니','로제']

final newList = blackPink.where((name)=> name == '리사' || name == '지수')

print(newList.toList()) // ['리사','지수'] // iterable 을 list 로 다시 반환할때 .toList() 사용
```

​ map() : List 에 있는 값을 순서대로 순회하며 값 변경 가능. 매개변수에 함수 입력해야함. 순회끝나면 이터러블 반환

​ reduce() : 순회하며 매개변수에 입력된 함수를 실행. 순회할때마다 값을 쌓아나감. List 멤버와 같은 타입 반환

​ fold() : reduce() 와 동일함. reduce는 함수가 실행되는 List 요소들의 타입이 같아야 하지만, fold() 함수는 어떤 타입이든 반환할 수 있음.

- Map : 키와 값의 짝으로 저장
  모든 Map 타입은 키와 값을 모두 반환 받을 수 있음.

  ```
  Map<String, String> dictionary = {
    'Harry Potter' : '해리포터',
    'Ron Weasley' : '론 위즐리'
  }

  print(dictionary.keys) // ('Harry Potter', 'Ron Weasley')
  ```

  ​

- Set : 중복없는 값들의 집합. 중복을 방지하므로, 유일한 값들만 존재한다는것을 보장함

- enum : 한 변수의 값을 몇 가지 옵션으로 제한하는 기능. 선택지가 제한적일떄 사용

  ```
  enum Status{
    approved,
    pending,
    rejected
  }
  ```

- 연산자

  - 단항연산 가능

    ```
    number ++
    number +=2
    ```

    ​

  - null 관련 연산자
    타입 키워드를 그대로 사용하면 null 값 저장 불가.

    ```
    double? number1 = 1; // 타입 뒤에 ?를 명시해서 Null 값 가질 수 있음
    number ??=4; // 기존에 Null 값일때만 값이 저장됨
    ```

  - 타입 비교 연산자 : is. !랑 같이 사용가능(반대의미)

  - switch 문 : 알맞은 case문 수행. enum 과 함께 사용하면 유용함.

  ```
  enum Status {
    approved,
    pending,
    rejected
  }

  Status status = Status.approved
  switch(status){
    case Status.approved:
    print('승인상태입니다)
    break;
    default:
    print('알수 없는 상태입니다')
  }

  ```

**1.7 함수와 람다**

- 함수의 일반적인 특징
  고정된 매개변수(위치 매개변수)

  이름이 있는 매개변수(명명된 매개변수) : 중괄호, required 키워드
  둘이 섞어서 쓸수도 있음. 섞어 쓸때는 Positional parameter 가 named parameter 보다 반드시 먼저 위치해야함

  ```
  int addNumbers(
  	int a, {
        required int b,
        int c = 4,
  	}) {
        return a+b+c
  	}

  void main(){
    print(addNumbers(1, b:3, c:7))//11
  }
  ```

  ​

- 익명 함수와 람다함수 : 둘다 함수 이름이 없음, 일회성으로 사용됨. 다트에서는 익명함수와 람다함수를 구분하지 않음.

  ```
  익명함수
  (매개변수){
    함수바디
  }

  람다 함수(이름을 정하고 선언할 필요없어서 글로벌 스코프로 다룰 필요가 없음)
  (매개변수) => 단 하나의 스테이트먼트(한줄이 아니라, 명령 단위가 하나여야 함)
  ```

  ​

- typedef와 함수
  typedef = 함수의 시그니처 정의. 시그니처란 반환값 타입, 매개변수 개수, 타입. 즉 함수 선언부를 정의하는 키워드

  ```
  typedef Operation = void Function(int x, int y)

  void add(int x, int y){
    print('결과값 : ${x + y}')
  }
  ```

  시그니처에 맞춘 함수를 만들어서 사용하면 됨

  다트에서 함수는 일급 객체이므로 함수를 값처럼 사용할 수 있음.

- try..catch
  throw 키워드를 사용해 에러를 고의적으로 발생시킬 수 있음
